---
title: Vue3实战难点
date: 2023-04-27 10:26:30
permalink: /pages/f4c038/
categories:
  - 技术
tags:
  - Vue3实战
---
## 在线预览Word

### word安装

- `npm i --save docx-preview@0.1.4`
- `npm i --save jszip@3.10.1`

### pdf安装

- `npm i --save pdfjs-dist@2.0.943`

### 使用

```js
<!-- 预览报告模板 -->
  <a-modal class="file-modal" v-model:visible="visibleFile" title="文件预览" :width="900" @ok="visibleFile = false">
    <template slot="footer">
        <a-button @click="visibleFile = false">确定</a-button>
    </template>
    <div ref="file"></div>
  </a-modal>

  <!-- 预览文件 -->
  <a-modal class="file-modal" v-model:visible="isShow" title="文件预览" :width="900" @ok="isShow = false">
    <template slot="footer">
        <a-button @click="isShow = false">确定</a-button>
    </template>
    <div ref="showFile" v-if="fileType == 'doc'"></div>
    <img :src="fileUrl" alt="" v-if="fileType == 'jpg'" class="fileUrl">
    <div id="printDom" ref="printDom" v-if="fileType == 'pdf'">
        <div v-for="item in state.numPages" :key="item">
            <canvas :id="`pdfCanvas-${item}`" :ref="`pdfCanvas-${item}`" />
        </div>
    </div>
  </a-modal>

// word
import axios from 'axios';
const docx = require('docx-preview');
window.JSZip = require('jszip')
// pdf
import * as pdfjsLib from 'pdfjs-dist'

// 预览总结报告模板
const showFileModal = (url) => {
  // 显示Word
  if (url.includes('.doc') || url.includes('.docx')) {
    visibleFile.value = true;
    axios({
        method: 'get',
        responseType: 'blob', // 设置响应文件格式
        url: url
    }).then(({ data }) => {
        docx.renderAsync(data, proxy.$refs.file) // 渲染到页面预览
    })
  } 
  // 显示PDF
  if(url.includes('pdf')) {
    showFile.isShow = true
    showFile.fileUrl = url
    showFile.fileType = 'pdf'

    pdfjsLib.GlobalWorkerOptions.workerSrc = '/pdf.worker.js'
    const loadingTask = pdfjsLib.getDocument({
        url: url,  //这里的pdfUrl即pdf的链接地址
        cMapUrl: '../../../../static/cmaps/',
        cMapPacked: true
    })
    loadingTask.promise.then(pdf => {
        // console.log('页数', pdf.numPages)
        state.numPages = pdf.numPages
        state.pdfCtx = pdf
        nextTick(() => {
            renderPdf()
        })
    })
  }
}

// 预览滚动样式
.file-modal {
  /deep/ .ant-modal {
    .ant-modal-body {
      max-height: calc(90vh - 150px);
      overflow-y: auto;
      &::-webkit-scrollbar {
        width: 6px;
        /*高宽分别对应横竖滚动条的尺寸*/
        height: 1px;
      }
    
      &::-webkit-scrollbar-thumb {
        background: #e3e3e6;
        border-radius: 6px;
      }
    
      &::-webkit-scrollbar-track {
        background: transparent;
        border-radius: 5px;
      }
    }
  }
  canvas {
    max-width: 850px !important;
  }
}
```



## 下载在线文档

- 本接口以word为例，接口以流的方式返回
- 需要对请求接口进行处理，对接口返回的响应头`content-disposition`进行处理
- 安装`npm i file-saver -S`

```js
// http.js
import request from '@/api/request'
import {encodeUrlParams} from "@/utils/utils";
const http = {
    get(url, params) {
        const config = {
            method: 'get',
            url: url
        } /*这里如果GET请求有参数，则携带上传入的参数，在
            URL中以？的方式放在请求链接中*/
        if (params) {
          if (params.page && Number.isSafeInteger(params.page) && params.page > 0) {
            params.pageNo = params.page;
            delete params.page;
          }
          encodeUrlParams(params);
          config.params = params
        }
        return request(config)
    },
    post(url, params) {
        const config = {
            method: 'post',
            url: url
        }/*同理也是传入用户需要发送到后台的参数，这些参数
            放在报文中，载体表达标准是JSON*/
        if (params) config.data = params
        return request(config)
    },
  postOf(url, params) {
    const config = {
      method: 'post',
      url: url,
      responseType: 'blob'
    }/*同理也是传入用户需要发送到后台的参数，这些参数
            放在报文中，载体表达标准是JSON*/
    if (params) config.data = params
    return request(config)
  },
    put(url, params) {
        const config = {
            method: 'put',
            url: url
        }/*同理也是传入用户需要发送到后台的参数，这些参数
            放在报文中，载体表达标准是JSON*/
        if (params) config.data = params
        return request(config)
    },
    del(url, params) {
        const config = {
            method: 'delete',
            url: url
        }/*这里如果DELETE请求有参数，则携带上传入的参数，在
            URL中以？的方式放在请求链接中*/
        if (params) config.params = params
        return request(config)
    },
}

//暴露接口，允许Vue文件或其他js,ts文件使用http结构体中的方法
export default http
```

```js
// requeset.js
import axios from 'axios';
import { message } from 'ant-design-vue';
import { removeStorage } from "@/utils/localStorage";
import store from '@/store/store'
// 创建一个自定义的Axios对象
const Axios = axios.create({
    baseURL: process.env.NODE_ENV === 'development' ? '/' : process.env.VUE_APP_API_HOST,
    timeout: 1000*30,
    /*也可以不设置Content-Type，影响是在你发送请求时
    Vue会先发送OPTIONS包探测路由是否存在，需要后端也做设置响应OPTIONS
    方法，否则会报跨域错误；我这里用的Beego2，路由里不响应OPTIONS方法，
    所以我在这块设置Content-Type*/
    // headers: {
    //     'Content-Type': 'application/x-www-form-urlencoded',
    // },
    /*这个配置很重要，允许axios携带用户Cookie到后端，不设置这个的话
    Set-Cookie是无效的,除此之外,Chrome默认开启了SameSite检查，如果
    后端不主动设置SameSite = none,Set-Cookie是无效的。*/
    // withCredentials: true
});
Axios.interceptors.request.use(req => {
    const token = sessionStorage.getItem('accessToken')
    if (token) {
        req.headers['X-Access-Token'] = token // 让每个请求携带自定义 token 请根据实际情况自行修改
    }
    // 请求拦截处理
    // console.log('这里是请求拦截器，我拦截了请求', req);
    return req;
}, err => {
    console.log('在发送请求时发生错误，错误为', err);
    //这里不能直接放回err,需要按照官方说明返回一个Promise
    return Promise.reject(err);
})
Axios.interceptors.response.use(res => {
    //token是否超过有效期
    let tokens = JSON.parse(sessionStorage.getItem('tokenTimes'))
    if(tokens&&tokens.termOfValidity){
        let nowTime = new Date();
        // console.log("得很好：",parseInt(nowTime-new Date(tokens.currentTime))/1000/60)
        // console.log("得很好：",new Date(tokens.currentTime))
        let timeDiff = parseInt(nowTime-new Date(tokens.currentTime))/1000/60;
        if(Math.ceil(timeDiff)>9){
            // console.log("需要刷新token了")
        }
    }
    // 获取文件名
    if(res.headers['content-disposition'])res.data['content-disposition'] = res.headers['content-disposition']
    // 响应拦截处理
    return res.data;
}, error => {
    const err = error.toString();
    //按照实际的响应包进行解析，通过关键字匹配的方式
    if (error.response?.message === 'Token失效，请重新登录'||error.response?.data.message === 'Token失效，请重新登录') {
        if (store.state.errIndex === 0) {
            message.error('很抱歉，登录已过期，请重新登录')
            store.commit('SET_ERR_INDEX', 1)
        }
        removeStorage();
        setTimeout(() => { 
            window.location.replace(process.env.VUE_APP_API_HOST2);
            window.name="'一体化平台'"
        }, 1500)
        return;
    }
    // switch (true) {
    //     case err.indexOf('Network') !== -1:
    //         console.log('后端服务器无响应或者URL错误', err);
    //         message.error('后端服务器无响应或者URL错误');
    //         break;
    //     case err.indexOf('timeout') !== -1:
    //         console.log('请求后端服务器超时！', err);
    //         message.error('请求后端服务器超时！');
    //         break;
    //     default:
    //         message.error(error.response.data.message||'接口请求出错！');
    //         break
    // }
    if(error.message.indexOf('Network') !== -1) {
        console.log('后端服务器无响应或者URL错误', err);
        message.error('后端服务器无响应或者URL错误');
    }else if (error.message.indexOf('timeout') !== -1) {
        console.log('请求后端服务器超时！', err);
        message.error('请求后端服务器超时！');
    }else {
        message.error(error.response?.data.message||'接口请求出错！');
    }
    return Promise.reject(error);
})
//暴露Axios实例化对象，允许所有文件调用Axios
export default Axios;
```

```js
import FileSaver from 'file-saver'

const exportDayReportFn = () => {
    exportDayReport({
        reportDate: dayjs(searchDate.value).format(dateFormat),
        sysOrgCode: sysOrgCode.value,
    }).then((res) => {
        let name = res['content-disposition'] ? decodeURIComponent(res['content-disposition'].split('=')[1].replace(/"/g,'')) : '无文件名'
        const blob = new Blob([res], { type: "application/octet-stream" });
        FileSaver.saveAs(blob, `${name}.docx`);
    }).catch((err) => {
        console.error(err);
    })
}
```

**主要是这里的配置**

```js
postOf(url, params) {
    const config = {
      method: 'post',
      url: url,
      responseType: 'blob'
    }/*同理也是传入用户需要发送到后台的参数，这些参数
            放在报文中，载体表达标准是JSON*/
    if (params) config.data = params
    return request(config)
}
  
 Axios.interceptors.response.use(res => {
    //token是否超过有效期
    let tokens = JSON.parse(sessionStorage.getItem('tokenTimes'))
    if(tokens&&tokens.termOfValidity){
        let nowTime = new Date();
        // console.log("得很好：",parseInt(nowTime-new Date(tokens.currentTime))/1000/60)
        // console.log("得很好：",new Date(tokens.currentTime))
        let timeDiff = parseInt(nowTime-new Date(tokens.currentTime))/1000/60;
        if(Math.ceil(timeDiff)>9){
            // console.log("需要刷新token了")
        }
    }
    // 获取文件名
    if(res.headers['content-disposition'])res.data['content-disposition'] = res.headers['content-disposition']
    // 响应拦截处理
    return res.data;
},error => {})

// 通过这个方法进行下载
FileSaver.saveAs(blob, `${name}.docx`);
```



## 预览图片水印

```js
<!-- 预览图片水印功能 -->
<div v-if="picVisible" class="pic-Modal" id="pic-Modal" @click="closePicModal" @mousewheel.prevent="handerPictu">
  <div id="pic-wrap"></div>
  <img ref="oImg" :src="picUrl" :style="{ width: picWidth, height: picHeight, zIndex: -1 }" alt=""/>
  <canvas id="picCanvas" />
</div>

<div class="pic-box">
    <a-image
      :src="item.filePath"
      :preview="false"
    />
    <div class="pic-content" @click="() => addWaterMark(true , index , item.filePath)" >
      <img src="@/assets/images/template/preview-default.png">
      <span>预览</span>
    </div>
</div>
  
  
// 现场情况图片预览水印
let picVisible = ref(false)
let imgCanvans = ''
let picCanvas = ''
let picIndex = ref(0)
let picUrl = ref('')
const addWaterMark = (value , index, url) => {
  picVisible.value = value;
  picUrl.value = url
  if (typeof index === 'number') {
    picIndex.value = index
  }
  if (picVisible.value) {
    nextTick(()=> {
      document.getElementById('pic-Modal').style.width = document.body.clientWidth + 'px'
      document.getElementById('pic-Modal').style.height = document.body.clientHeight + 'px'
      document.body.parentNode.style.overflow = 'hidden'

      imgCanvans = document.getElementById('pic-wrap')
      picCanvas = document.getElementById('picCanvas')
      picCanvas.width = 600
      picCanvas.height = 200

      picCanvas.style.display = 'none'
      const ctx = picCanvas.getContext('2d')
      ctx.font = '16px Microsoft JhengHei'
      ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'
      ctx.rotate(-0.35)
      ctx.fillText(`${dayjs(Date.now()).format('YYYY-MM-DD HH:mm:ss')}       ${store.state.userInfo.realname}`, 125, picCanvas.height / 1)
      ctx.fillText(`协同调度系统`, 0 , picCanvas.height / 1)

      const img = picCanvas.toDataURL('image/png')
      const style = `background-image:url(${img})`
      imgCanvans.setAttribute('style', style)
    })
  } else {
    imgCanvans.style.display = 'none'
  }
}

// 预览图片resize监听
const picChangeResize = () => {
  if (picVisible.value) {
    document.getElementById('pic-Modal').style.width = document.body.clientWidth + 'px'
    document.getElementById('pic-Modal').style.height = document.body.clientHeight + 'px'
  }
}

// 预览图片放大缩小图片
let picWidth = ref('fit-content')
let picHeight = ref('fit-content')
const handerPictu = (e) => {
  let transforms = proxy.$refs.oImg.style.transform
  let zoom = transforms.indexOf("scale") != -1 ? +transforms.split("(")[1].split(")")[0] : 1
  zoom += e.wheelDelta / 1200
  if (zoom > 0.1 && zoom < 2) {
    proxy.$refs.oImg.style.transform = "scale(" + zoom + ")"
  }
}

const closePicModal = () => {
  picVisible.value = false
  document.body.parentNode.style.overflow = 'auto'
  picWidth.value = 'fit-content'
  picHeight.value  = 'fit-content'
}

onMounted(()=>{
  window.addEventListener("resize", picChangeResize)
});

onUnmounted(()=> {
    window.removeEventListener('resize', picChangeResize)
})

return{
  // 图片预览水印
  picVisible,
  picIndex,
  addWaterMark,
  closePicModal,
  handerPictu,
  picWidth,
  picHeight,
  picUrl,
}

// 图片水印
.pic-scene-box {
  width: 100%;
  height: 100%;
  /deep/ .ant-image {
    width: 100%;
    height: 100%;
    img {
      width: 100%;
      height: 100%;
    }
  }
}
.pic-box {
  position: relative;
 &:hover {
    cursor: pointer;
 }
 &:hover .pic-content {
  display: flex;
  justify-content: center;
  align-items: center;
  position: absolute;
  top: 0;
  left: 0;
  background-color: rgba(127,127,127,0.5);
  z-index: 9999;
  width: 100%;
  height: 100%;
  color: #fff;
  img {
    width: 26px;
    height: 26px;
    margin-right: 5px;
  }
 }
}
.pic-content {
  display: none;
  width: 100%;
  height: 100%;
}
.pic-Modal {
  position: fixed;
  top: 0;
  left: 0;
  background-color: rgba(0, 0, 0, 0.45);
  z-index: 9999;
  display: flex;
  justify-content: center;
  align-items: center;
  #pic-wrap {
    width: 100%;
    height: 100%;
    position: fixed;
    top: 0;
    left: 0;
  }
  img {
    min-width: 30px !important;
    min-height: 30px !important;
    max-width: 1240px !important;
    max-height: 1240px !important;
  }
}
```



## 预览视频水印

- `npm i vue3-video-play` (1.3.1-beta.6)

```js
<!-- 预览视频水印Canvas -->
<canvas id="videoCanvans"></canvas>

<template v-for="(item,index) in globalData.eventDetailsObj.videoAttachment" :key="item.id">
    <!-- 视频预览水印 -->
    <div class="fileItem" v-if="globalData.sceneTypeTabKey == 0 || globalData.sceneTypeTabKey == 2 || (globalData.sceneTypeTabKey == 4 && item.resourceType == 1)">
        <video-play
          v-bind="options" 
          :src="item.filePath"
          @play="onPlay(index)"
        />
    </div>
</template>

<!-- 视频 -->
<div v-else-if="ele.videoUrl" class="videoBox">
    <video-play
      v-bind="options" 
      :src="ele.videoUrl"
      @play="onPlaySend(ele.videoTotal)"
    />
</div>

import { videoPlay } from 'vue3-video-play'
components: {
	videoPlay,
}
    
const options = reactive({
  width: '100%', //播放器高度
  height: '100%', //播放器高度
  // color: "#409eff", //主题色
  muted: false, //静音
  webFullScreen: false,
  speedRate: ["0.75", "1.0", "1.25", "1.5", "2.0"], //播放倍速
  autoPlay: false, //自动播放
  loop: false, //循环播放
  mirror: false, //镜像画面
  ligthOff: false,  //关灯模式
  volume: 0.3, //默认音量大小
  control: true, //是否显示控制器
  controlBtns: [
    "audioTrack",
    "quality",
    "speedRate",
    "volume",
    "setting",
    "fullScreen",
  ], //显示所有按钮,
  title: '', //视频名称
  // src: "http://vjs.zencdn.net/v/oceans.mp4", //视频源
  poster: '', //封面
})

// 监听视频是否处于全屏状态并设置当前水印时间
let nowDate = ''
let videoActiveIndex = ref('')
const checkIsFullScreen = () => {
    var isFullScreen = document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen;
    return isFullScreen == undefined ? false : isFullScreen;
}
const fullScreenChange = () => {
  if (checkIsFullScreen()) {
      console.log("进入全屏");
      nowDate = dayjs(Date.now()).format('YYYY-MM-DD HH:mm:ss')
      if (videoActiveIndex.value !== '') {
        document.querySelectorAll('.d-player-control')[videoActiveIndex.value].style.setProperty('height', '50px', 'important');
      }

      // 获取所有类名为 top-title 的 p 元素
      const pElements = document.querySelectorAll('p.top-title');
      if (pElements.length !== 0) {
        // 遍历 p 元素列表，并移除类名为 top-title 的元素
        pElements.forEach((pElement) => {
          pElement.remove()
        });
      }
  } else {
      console.log("退出全屏");
      if (videoActiveIndex.value !== '') {
        document.querySelectorAll('.d-player-control')[videoActiveIndex.value].style.setProperty('height', '30px', 'important');
      }
  }
}

// 视频预览水印
const onPlay = (index) => {
    if (!nowDate) {
      nowDate = dayjs(Date.now()).format('YYYY-MM-DD HH:mm:ss')
    }

    imgCanvans = document.getElementsByClassName('d-player-state')[index]
    picCanvas = document.getElementById('videoCanvans')
    picCanvas.width = 600
    picCanvas.height = 200

    picCanvas.style.display = 'none'
    const ctx = picCanvas.getContext('2d')
    ctx.font = '16px Microsoft JhengHei'
    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'
    ctx.rotate(-0.35)
    ctx.fillText(`${nowDate}       ${store.state.userInfo.realname}`, 125, picCanvas.height / 1)
    ctx.fillText(`协同调度系统`, 0 , picCanvas.height / 1)

    const img = picCanvas.toDataURL('image/png')
    const style = `background-image:url(${img})`
    imgCanvans.setAttribute('style', style)
}

// 协同处置视频预览水印
let videoTotal = ref(0)
const onPlaySend = (videoTotal) => {
    videoActiveIndex.value = videoTotal
    if (!nowDate) {
      nowDate = dayjs(Date.now()).format('YYYY-MM-DD HH:mm:ss')
    }

    imgCanvans = document.getElementsByClassName('d-player-state')[videoTotal]
    picCanvas = document.getElementById('videoCanvans')
    picCanvas.width = 600
    picCanvas.height = 200

    picCanvas.style.display = 'none'
    const ctx = picCanvas.getContext('2d')
    ctx.font = '16px Microsoft JhengHei'
    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'
    ctx.rotate(-0.35)
    ctx.fillText(`${nowDate}       ${store.state.userInfo.realname}`, 125, picCanvas.height / 1)
    ctx.fillText(`协同调度系统`, 0 , picCanvas.height / 1)

    const img = picCanvas.toDataURL('image/png')
    const style = `background-image:url(${img})`
    imgCanvans.setAttribute('style', style)
}

onMounted(()=>{
  window.addEventListener('fullscreenchange', fullScreenChange)
});

onUnmounted(()=> {
  window.removeEventListener('fullscreenchange', fullScreenChange)
})
    
return{
  // 视频预览水印
  options,
  onPlay,
  onPlaySend,
  info,
  isLoading,
  isAlreadyEventType,
  eventDetailsLoadings,
  isActivated,
  debounce2,
}
```



## 内嵌非菜单tab

```js
import Layout from '@/views/layout'

export default {
    path: '/amc/order-mgt',
    component: Layout,
    redirect: '/amc/order-mgt/order-list',
    name: 'AmcOrderMgt',
    meta: {
        title: '订单管理',
        icon: 'supplier-goods-mgt',
        onBar: false // onBar控制是否显示出来
    },
    children: [
        {
            path: 'order-list',
            name: 'AmcOrderList',
            component: () => import('@/views/amc/order-mgt/order-list.vue'),
            meta: { title: '订单管理' }
        },
        {
            path: 'order-detail',
            name: 'AmcOrderDetail',
            component: () => import('@/views/amc/order-mgt/order-detail.vue'),
            hidden: true,
            meta: {
                title: '订单详情',
                insertRoute: {
                    name: 'AmcOrderList',
                    path: '/amc/order-mgt/order-list',
                    meta: { title: '订单管理' }
                }
            }
        },
        {
            path: 'aftersale-list-v2',
            name: 'AmcAftersaleListV2',
            component: () =>
                import('@/views/amc/order-mgt/aftersale-list-v2.vue'),
            meta: { title: '售后管理' }
        },
        {
            path: 'aftersale-detail-v2',
            name: 'AmcAftersaleDetailV2',
            component: () =>
                import('@/views/amc/order-mgt/aftersale-detail-v2.vue'),
            hidden: true,
            meta: {
                title: '售后详情',
                insertRoute: {
                    name: 'AmcAftersaleListV2',
                    path: '/omc/order-mgt/aftersale-list-v2',
                    meta: { title: '售后管理' }
                }
            }
        }
    ]
}
```



## 动态KeepAlive

- 解决keepAlive关闭tab页面再次打开依旧有缓存问题
- 以include的方式动态进行缓存

```js
<router-view 
    v-slot="{ Component }" 
    :class="{
        'right-box': !collapseds && indexObj.isSideMenuShow.bool == true,
        'right-box right-box2': (collapseds && indexObj.isSideMenuShow.bool == true) || isReload,
        'other-box3': routerName === 'home',
        'other-box5': routerName === 'eventDetails2',
      }">
    <keep-alive :include="$store.state.keepAlive">
      <component :is="Component"/>
    </keep-alive>
</router-view>

// store.js
const store = createStore({
	state: {
		keepAlive: ['roadOverviewNew'],
	},
	mutations: {
		SET_KEEPALIVE(state,obj){
            state.keepAlive = obj
        },
        REMOVE_KEEPALIVE(state,obj){
            const index = state.keepAlive.indexOf(obj[0])
            index > -1 && state.keepAlive.splice(index, 1)
        },
        ADD_KEEPALIVE(state,obj){
            state.keepAlive.push(obj[0])
        }
	}
})

// permisson.js 每次打开需要重新初始化
store.commit("SET_KEEPALIVE", ['roadOverviewNew'])

// utils.js
// 缓存菜单路由数据
export const menuObj = {
    '通知对象管理': 'tbNoticeChannelInfo',
    '事件评价项目管理': 'tbEventEvaluateProject',
    '事件类型管理': 'tbEventCategory',
    '事件评价标签管理': 'tbEventEvaluateLabel',
    '处置模型管理': 'tbDisposalModelV2',
    '值班人员管理': 'operator',
    '班次规则设置': 'electronicFence',
    '我的消息': 'MyMessage',
    '日常工作总结': 'dailyWorkReport',
    '事件信息': 'eventInformation2',
    '事件信息统计': 'dataStatistics',
    '人工日月报表': 'DailyMonthWorkReport',
    '处置节点基础信息': 'tbDisposalNodeInfo',
    '评价项目': 'tbEventEvaluateProject',
    '评价标签': 'tbEventEvaluateLabel'
}

// index.vue
import { menuObj } from "@/utils/utils";
const getMenuTabs = (res) => {
  console.log('--点击左菜单--', res)
  // 添加需要缓存的菜单路由
  let list = []
  if (res.meta.title && menuObj.hasOwnProperty(res.meta.title) && res.meta.title !== '路况总览' && !store.state.keepAlive.includes(menuObj[res.meta.title])) {
    list.push(menuObj[res.meta.title])
    store.commit('ADD_KEEPALIVE', list)
    list = []
  } 
}

// GlobalHeader.vue
import { menuObj } from "@/utils/utils";
const tabCloseClick = (item, index) => {
  // 移出需要缓存的菜单路由
  let list = []
  if (item.path && !item.path.includes('eventDetails2') && menuObj.hasOwnProperty(item.meta.title) && item.meta.title !== '路况总览') {
    list.push(menuObj[item.meta.title])
    store.commit('REMOVE_KEEPALIVE', list)
    list = []
  }
}
```



## 高德地图

- `npm i @amap/amap-jsapi-loader -S`（^1.0.1）
- 打点`Marker`
- 点聚合`MarkerClusterer`
- 全局挂载`index.html`：挂载完`window`会自动暴露一个`AMap`变量，之后进行引用即可

> 注意：高德地图不要用响应式数据去存储，响应式数据会造成意想不到的bug

```html
<script type="text/javascript">
    window._AMapSecurityConfig = {
        securityJsCode:'709c59ab035b7c6f660a8e731d709c99',
    }
</script>
<script type="text/javascript" src="http://webapi.amap.com/maps?v=1.4.5&key=7420458a9eaeb41505d4e45016e3adb9&plugin=AMap.PolyEditor,AMap.CircleEditor,AMap.MarkerClusterer"></script> 
<script>
```

```js
<!-- 提示 -->
<a-spin :spinning="mapObj.mapLoading" tip="高速公路大脑为您加速">
	<div id="container" class="pa"></div>
</a-spin>
<!-- 人员点聚合信息窗体 -->
<div class="clusterWindowBox" ref="clusterWindowBoxRef" :style="{width:clusterArr.length == 1?'211px':''}">
    <div class="clusterWindowItem" :class="clusterArr.length == 1?'oneCluster':''" v-for="(item,index) in clusterArr" :key="index" >
      <p :title="item.orgName"><span>部门：</span>{{item.orgName}}</p>
      <p :title="item.realName"><span>姓名：</span>{{item.realName}}</p>
      <p :title="item.workStatus_dictText"><span>状态：</span>{{item.workStatus_dictText}}</p>
      <p :title="item.phone"><span>电话：</span>{{item.phone}}</p>
    </div>
</div>
<!-- 事件点聚合信息窗体 -->
<div class="clusterWindowBox" ref="clusterEventWindowBoxRef" :style="{width:clusterEventArr.length == 1?'211px':''}">
    <div class="clusterWindowItem clusterEventWindowItem" :class="clusterEventArr.length == 1?'oneCluster':''" v-for="(item,index) in clusterEventArr" :key="index" @click="toEventDetailsFn(item)">
      <p class="clusterEventWindowItem-name" :title="item.name">{{item.name}}</p>
      <p :title="item.eventTime"><span>事件时间：</span>{{item.eventTime}}</p>
      <p :title="item.categoryName"><span>分类：</span>{{item.categoryName}}</p>
      <p :title="item.chaiageNum"><span>桩号：</span>{{item.chaiageNum}}</p>
      <p :title="item.trafficState"><span>交通状况：</span>{{item.trafficState}}</p>
    </div>
</div>

import AMapLoader from '@amap/amap-jsapi-loader'

let GDMap = null
let personMarkerClusterer = null
let eventMarkerClusterer1 = null
let eventMarkerClusterer2 = null
let eventMarkerClusterer3 = null
let eventMarkerClusterer4 = null
let eventMarkerClusterer5 = null
let accidentMarkerArr1 = []
let accidentMarkerArr2 = []
let accidentMarkerArr3 = []
let accidentMarkerArr4 = []
let accidentMarkerArr5 = []

const clusterInfoWindow = ref(null)
const clusterArr = ref([])
const clusterEventArr = ref([])
const clusterWindowBoxRef = ref(null)
const clusterEventWindowBoxRef = ref(null)

// 地图初始化
const initMap = async () => {
  GDMap = new window.AMap.Map('container', {
    center: [113.338552, 23.076839],
    zoom: 13,
    viewMode: '3D',
    pitch: 60, // 地图俯仰角度，有效范围 0 度- 83 度
    mapStyle: 'amap://styles/whitesmoke',
  })
  GDMap.on('complete', (e) => {
    mapObj.mapLoading = false
    // mapObj.isMapLoaded = true
    // setTimeout(() => {
    getSectionInfoApiFn() //画线路
    queryEventInfoApiFn() //地图加载重大交通事故地点图标位置
    // }, 1000)
  })
  GDMap.on('mousewheel', (e) => {
    if(clusterInfoWindow){
      clusterInfoWindow.close()
      clusterArr.value = []
      clusterEventArr.value = []
      clusterYiGouEventArr.value = []
    }
  })
  GDMap.on('click', (e) => {
  })
}

//地图加载重大交通事故地点图标位置
const accidentMarkerFn = (data) => {
  if(GDMap) {
    GDMap.remove(accidentMarkerArr1)
    GDMap.remove(accidentMarkerArr2)
    GDMap.remove(accidentMarkerArr3)
    GDMap.remove(accidentMarkerArr4)
    GDMap.remove(accidentMarkerArr5)
    accidentMarkerArr1 = []
    accidentMarkerArr2 = []
    accidentMarkerArr3 = []
    accidentMarkerArr4 = []
    accidentMarkerArr5 = []

    // 每次打点都需要清除点聚合对象
    if (eventMarkerClusterer1) {
      GDMap.remove(eventMarkerClusterer1)
      eventMarkerClusterer1 = null
    }
    if (eventMarkerClusterer2) {
      GDMap.remove(eventMarkerClusterer2)
      eventMarkerClusterer2 = null
    }
    if (eventMarkerClusterer3) {
      GDMap.remove(eventMarkerClusterer3)
      eventMarkerClusterer3 = null
    }
    if (eventMarkerClusterer4) {
      GDMap.remove(eventMarkerClusterer4)
      eventMarkerClusterer4 = null
    }
    if (eventMarkerClusterer5) {
      GDMap.remove(eventMarkerClusterer5)
      eventMarkerClusterer5 = null
    }
    // 查找事件数据是否有经纬度相同的点，有则删除
    // data.forEach((targetItem, index) => {
    //   let isHasPoint = data.findIndex((item) => {
    //     if (targetItem.levelId === item.levelId && targetItem.id !== item.id) {
    //       return (targetItem.longitude === item.longitude) && (targetItem.latitude === item.latitude)
    //     }
    //   })
    //   if (isHasPoint > -1) {
    //     data.splice(index, 1)
    //   }
    // })
    // //console.log('事件点数据', data)
    // data.push({ //测试数据测试点位置是否准确
    //   name:'海珠广场',
    //   latitude:'23.115241',
    //   longitude:'113.265813',
    //   levelId:5
    // })
    data.forEach((e, i) => {
      if (e.longitude && e.latitude) {
        let icon = ''
        if (e.levelId == 1) {
          icon = new AMap.Icon({
            imageSize: new AMap.Size(36, 36),
            imageOffset:new AMap.Pixel(0,0),
            image: require('@/assets/images/roadOverview/map-event-icon1.png'),
          })
        } else if (e.levelId == 2) {
          icon = new AMap.Icon({
            imageSize: new AMap.Size(36, 36),
            imageOffset:new AMap.Pixel(0,0),
            image: require('@/assets/images/roadOverview/map-event-icon2.png'),
          })
        } else if (e.levelId == 3) {
          icon = new AMap.Icon({
            imageSize: new AMap.Size(36, 36),
            imageOffset:new AMap.Pixel(0,0),
            image: require('@/assets/images/roadOverview/map-event-icon3.png'),
          })
        } else if(e.levelId == 4){
          icon = new AMap.Icon({
            imageOffset:new AMap.Pixel(0,0),
            imageSize: new AMap.Size(36, 36),
            image: require('@/assets/images/roadOverview/map-event-icon4.png'),
          })
        } else {
          icon = new AMap.Icon({
            imageSize: new AMap.Size(36, 36),
            imageOffset:new AMap.Pixel(0,0),
            image:require('@/assets/images/roadOverview/map-event-icon5.png')
          })
        }
        let accidentMarker = new AMap.Marker({
          icon:icon,
          size:new AMap.Size(36,36), 
          offset: new AMap.Pixel(0,0),
          anchor:'bottom-center',
          position: [e.longitude, e.latitude],
          extData: e
        })

        // 信息窗（会有部分点无法展示展示窗的bug）
        // let infoWindow = new AMap.InfoWindow({
        //   offset: new AMap.Pixel(0, -36),
        // })
        let infoWindowObj = e
        if (infoWindowObj.trafficState == '1') {
          infoWindowObj.trafficState = '畅通'
        } else if (infoWindowObj.trafficState == '2') {
          infoWindowObj.trafficState = '缓行'
        } else if (infoWindowObj.trafficState == '3') {
          infoWindowObj.trafficState = '拥堵'
        } else if (infoWindowObj.trafficState == '4') {
          infoWindowObj.trafficState = '严重拥堵'
        }

        // 标记点的头部label,用于替代infoWindow
        accidentMarker.setLabel({
          direction:'top',
          // offset: new AMap.Pixel(110,-100),  //设置文本标注偏移量
          content: `<div id='test${i}'><div class="roadOverviewMarkerDialog-title">${infoWindowObj.name}</div>
            <div class="roadOverviewMarkerDialog-content mt_10">事件时间：${infoWindowObj.eventTime}</div>
            <div class="roadOverviewMarkerDialog-content mt_10">分    类：${
              infoWindowObj.categoryName == null ? '' : infoWindowObj.categoryName
            }</div>
            <div class="roadOverviewMarkerDialog-content mt_10">桩    号：${
              infoWindowObj.chaiageNum == null ? '' : infoWindowObj.chaiageNum
            }</div>
            <div class="roadOverviewMarkerDialog-content mt_10">交通状况：${infoWindowObj.trafficState}</div>
            </div>`, 
        });

        let top,left
        // 鼠标移入
        accidentMarker.on('mouseover', function (e) {
          // 对label样式修改并进行展示
          document.getElementById(`test${i}`).parentNode.style='display:block;position:absolute;top:-140px;left:-90px;'
          top = document.getElementById(`test${i}`).parentNode.parentNode.style.top
          left = document.getElementById(`test${i}`).parentNode.parentNode.style.left
          document.getElementById(`test${i}`).parentNode.parentNode.style=`z-index:101;top:${top};left:${left}`

          // 注册infoWindow内容并展示
          // if(clusterInfoWindow.value){
          //   clusterInfoWindow.value.close()
          // }
          // let infoWindowContent = `<div ><div class="roadOverviewMarkerDialog-title">${infoWindowObj.name}</div>
          //   <div class="roadOverviewMarkerDialog-content mt_10">事件时间：${infoWindowObj.eventTime}</div>
          //   <div class="roadOverviewMarkerDialog-content mt_10">分    类：${
          //     infoWindowObj.categoryName == null ? '' : infoWindowObj.categoryName
          //   }</div>
          //   <div class="roadOverviewMarkerDialog-content mt_10">桩    号：${
          //     infoWindowObj.chaiageNum == null ? '' : infoWindowObj.chaiageNum
          //   }</div>
          //   <div class="roadOverviewMarkerDialog-content mt_10">交通状况：${infoWindowObj.trafficState}</div>
          //   </div>`
          // console.log('进入',GDMap,infoWindowContent,e.target.getPosition());
          // infoWindow.setContent(infoWindowContent)
          // infoWindow.open(GDMap, e.target.getPosition())
        })
        // 鼠标移出
        accidentMarker.on('mouseout', function (e) {
          // 隐藏label
          document.getElementById(`test${i}`).parentNode.style='display:none'
          document.getElementById(`test${i}`).parentNode.parentNode.style=`z-index:100;top:${top};left:${left}`

          // 关闭infoWindow
          // infoWindow.close(GDMap, accidentMarker.getPosition())
        })

        accidentMarker.on('click', function (e) {
          if(clusterInfoWindow.value){
            clusterInfoWindow.value.close()
          }
          toEventDetailsFn(accidentMarker.getExtData())
        })

        if (e.levelId == 1) {
          accidentMarkerArr1.push(accidentMarker)
        } else if (e.levelId == 2) {
          accidentMarkerArr2.push(accidentMarker)
        } else if (e.levelId == 3) {
          accidentMarkerArr3.push(accidentMarker)
        } else if (e.levelId == 4) {
          accidentMarkerArr4.push(accidentMarker)
        } else if (e.levelId == 5) {
          accidentMarkerArr5.push(accidentMarker)
        }
      }
    })
    GDMap.add(accidentMarkerArr1)
    GDMap.add(accidentMarkerArr2)
    GDMap.add(accidentMarkerArr3)
    GDMap.add(accidentMarkerArr4)
    GDMap.add(accidentMarkerArr5)
    // 点击事件点聚合功能
    addCluster(accidentMarkerArr1, 'levelId', 1)
    addCluster(accidentMarkerArr2, 'levelId', 2)
    addCluster(accidentMarkerArr3, 'levelId', 3)
    addCluster(accidentMarkerArr4, 'levelId', 4)
    addCluster(accidentMarkerArr5, 'levelId', 5)
  }
}

// 地图资源设备打点
const drawRoadOverviewMarkerFn = (data, type) => {
  if (data.length > 0) {
    // 每次打点初始化数据,并且都需要清除点聚合对象
    mapDetailObj.mapIconArr10 = []
    if (personMarkerClusterer) {
      GDMap.remove(personMarkerClusterer)
      personMarkerClusterer = null
    }
    data.forEach((e, i) => {
      if (e.longitude && e.latitude) {
        let size = new AMap.Size(36,36) 
        let icon = new AMap.Icon({
          image:e.birdgeName != undefined
            ? mapIconList.value[0]
            : e.tollGateName != undefined
            ? mapIconList.value[1]
            : e.serviceAreaName != undefined
            ? mapIconList.value[2]
            : e.tunnelName != undefined
            ? mapIconList.value[3]
            : e.cameraName != undefined
            ? mapIconList.value[4]
            : e.portalName != undefined
            ? mapIconList.value[5]
            : e.vmsName != undefined
            ? mapIconList.value[6]
            : e.chainageName != undefined
            ? mapIconList.value[7]
            : e.realName != undefined
            ? mapIconList.value[9]
            : '', // Icon的图像
          imageSize: size, // 根据所设置的大小拉伸或压缩图片
          imageOffset:new AMap.Pixel(0,0),
        })
        let name = e.birdgeName != undefined
            ? e.birdgeName
            : e.tollGateName != undefined
            ? e.tollGateName
            : e.serviceAreaName != undefined
            ? e.serviceAreaName
            : e.tunnelName != undefined
            ? e.tunnelName
            : e.cameraName != undefined
            ? e.cameraName
            : e.portalName != undefined
            ? e.portalName
            : e.vmsName != undefined
            ? e.vmsName
            : e.chainageName != undefined
            ? e.chainageName
            : e.realName != undefined
            ? e.realName
            : ''
        if (e.realName != undefined) {
          let content = `<div class="markerBox">
          <img src="${mapIconList.value[9]}" class="markerImage"/>
          <div class="markerContent">
            <p>${e.realName}</p>
          </div>
        </div>`
          // let content = `<div class="personnel-map-box pr"><span class="personnel-map-box-item pa">${e.realName}</span></div>`
          mapDetailObj.roadOverviewMarker = new AMap.Marker({
            content: content,
            position: [e.longitude, e.latitude],
            size:new AMap.Size(36,36), 
            offset: new AMap.Pixel(40,0),
            anchor:'bottom-center',
            zIndex: 10,
            extData: e,
          })
        } else {
          mapDetailObj.roadOverviewMarker = new AMap.Marker({
            icon: icon,
            position: [e.longitude, e.latitude],
            size:new AMap.Size(36,36), 
            offset: new AMap.Pixel(0,0),
            anchor:'bottom-center',
            zIndex: 10,
            extData: e,
          })
        }

        let infoWindow = new AMap.InfoWindow({ offset: new AMap.Pixel(0, -36) })
        let infoWindowObj = e
        mapDetailObj.roadOverviewMarker.on('mouseover', function (e) {
          let infoWindowContent = ''
          if (infoWindowObj.realName != undefined) {
            infoWindowContent = `<div>
                <div class="roadOverviewMarkerDialog-content mt_10">部门：${infoWindowObj.orgName}</div>
                <div class="roadOverviewMarkerDialog-content mt_10">姓名：${name}</div>
                <div class="roadOverviewMarkerDialog-content mt_10">状态：${infoWindowObj.workStatus_dictText}</div>
                <div class="roadOverviewMarkerDialog-content mt_10">电话：${infoWindowObj.phone}</div>
                </div>`
          } else {
            infoWindowContent = `<div ><div class="roadOverviewMarkerDialog-title">${infoWindowObj.orgName}</div>
            <div class="roadOverviewMarkerDialog-content mt_10">名称：${name}</div>
            </div>`
          }
          infoWindow.setContent(infoWindowContent)
          infoWindow.open(GDMap, e.target.getPosition())
        })
        mapDetailObj.roadOverviewMarker.on('mouseout', function (e) {
          infoWindow.close(GDMap, mapDetailObj.roadOverviewMarker.getPosition())
        })

        mapDetailObj.roadOverviewMarker.on('click', (e) => {
          const extData = e.target.getExtData()
          ////console.log('extData:', extData)
          if (extData.chainageName != undefined) {
            yiGouObj.isMileageDetailShow = true
            yiGouObj.mileageId = extData.chainageCode
            ////console.log('chainageCode:', yiGouObj.mileageId)
          } else if (extData.vmsName != undefined) {
            yiGouObj.isInfoDetailShow = true
            yiGouObj.infoId = extData.vmsCode
          } else if (extData.portalName != undefined) {
            yiGouObj.isGantryDetailsShow = true
            yiGouObj.gantryId = extData.portalCode
          } else if (extData.cameraName != undefined) {
            yiGouObj.isVideoWindowShow = true
            yiGouObj.cameraNum = extData.cameraCode
          } else {
            // roadOverviewMarkerDialogFn(extData)
          }
        })
        GDMap.add(mapDetailObj.roadOverviewMarker)
        if (e.birdgeName != undefined) {
          mapDetailObj.mapIconArr1.push(mapDetailObj.roadOverviewMarker)
        } else if (e.tollGateName != undefined) {
          mapDetailObj.mapIconArr2.push(mapDetailObj.roadOverviewMarker)
        } else if (e.serviceAreaName != undefined) {
          mapDetailObj.mapIconArr3.push(mapDetailObj.roadOverviewMarker)
        } else if (e.tunnelName != undefined) {
          mapDetailObj.mapIconArr4.push(mapDetailObj.roadOverviewMarker)
        } else if (e.cameraName != undefined) {
          mapDetailObj.mapIconArr5.push(mapDetailObj.roadOverviewMarker)
        } else if (e.portalName != undefined) {
          mapDetailObj.mapIconArr6.push(mapDetailObj.roadOverviewMarker)
        } else if (e.vmsName != undefined) {
          mapDetailObj.mapIconArr7.push(mapDetailObj.roadOverviewMarker)
        } else if (e.chainageName != undefined) {
          mapDetailObj.mapIconArr8.push(mapDetailObj.roadOverviewMarker)
        } else if (e.realName != undefined) {
          mapDetailObj.mapIconArr10.push(mapDetailObj.roadOverviewMarker)
        }
        // else if (e.type==9) {
        //   mapDetailObj.mapIconArr9.push(mapDetailObj.roadOverviewMarker)
        // }
      }
    })
    if (type == 'gateInfo') {
      let middleIndex = Math.ceil(data.length / 2)
      GDMap.setCenter([data[middleIndex].longitude, data[middleIndex].latitude])
      // GDMap.setZoom(10.36)
      GDMap.setZoom(11.97)
    }
    // 点击人员点聚合功能
    if (type === 10) {
      addCluster(mapDetailObj.mapIconArr10, 'person')
    }
  }
}

// 值班人员和事件点聚合
function addCluster(markerArr, type, levelId){ 
  console.log('markerArr',markerArr)
  let typeClusterStyle = ''
  let typeEventClusterStyle = ''
  if (type === 'person') {
    typeClusterStyle = 'renderClusterBox'
    typeEventClusterStyle = 'renderClusterCount'
  } else {
    if (levelId === 1) {
      typeClusterStyle = 'renderEventClusterBox1'
      typeEventClusterStyle = 'renderEventClusterCount1'
    }
    if (levelId === 2) {
      typeClusterStyle = 'renderEventClusterBox2'
      typeEventClusterStyle = 'renderEventClusterCount2'
    }
    if (levelId === 3) {
      typeClusterStyle = 'renderEventClusterBox3'
      typeEventClusterStyle = 'renderEventClusterCount3'
    }
    if (levelId === 4) {
      typeClusterStyle = 'renderEventClusterBox4'
      typeEventClusterStyle = 'renderEventClusterCount4'
    }
    if (levelId === 5) {
      typeClusterStyle = 'renderEventClusterBox5'
      typeEventClusterStyle = 'renderEventClusterCount5'
    }
  }
  let _renderClusterMarker = function(context){
    let content=`<div class="renderAnyClusterBox ${typeClusterStyle}">
      <div class="renderAnyClusterCount ${typeEventClusterStyle}">${context.count}</div></div>`
    context.marker.setOffset(new AMap.Pixel(-21, -21));
    context.marker.setContent(content)
  }
  let _renderMarker = function(context) {
    let content = `<div class="markerBox">
      <img src="${mapIconList.value[9]}" class="markerImage"/>
      <div class="markerContent">
        <p>${context.data[0].realName}</p>
      </div>
    </div>`
    var offset = new AMap.Pixel(0,0);
    context.marker.setContent(content)
    context.marker.setOffset(offset)
    context.marker.setAnchor('bottom-center')
  }
  if(!personMarkerClusterer && type === 'person'){
    personMarkerClusterer = new AMap.MarkerClusterer(
      GDMap,
      markerArr,
      {
        renderClusterMarker: _renderClusterMarker, // 自定义聚合点样式
        renderMarker: _renderMarker, // 自定义非聚合点样式
        gridSize: 60, //聚合计算时网格的像素大小
        maxZoom: 18, //最大的聚合级别
        zoomOnClick:true,
        // clusterByZoomChange:true,
      }
    )
    personMarkerClusterer.on('click',(ele)=>{
      // 2.0版本的使用 
      // clusterArr.value = ele.clusterData
      // clusterInfoWindow.value = new AMap.InfoWindow({
      //   offset:ele.clusterData.length>1 ? new AMap.Pixel(0,-36) : new AMap.Pixel(0, -36),
      //   anchor:'bottom-center',
      //   content:clusterWindowBoxRef.value,
      //   isCustom:true
      // })
      // clusterInfoWindow.value.open(GDMap, [ele.lnglat.lng,ele.lnglat.lat])

      // 1.4.15版本的使用
      if (GDMap.getZoom() === 18) {
        clusterArr.value.length = 0
        ele.markers.forEach((item)=>{
          clusterArr.value.push(item.getExtData())
        })
        clusterInfoWindow.value = new AMap.InfoWindow({
          offset:new AMap.Pixel(0,-36),
          anchor:'bottom-center',
          content:clusterWindowBoxRef.value,
          isCustom:true
        })
        clusterInfoWindow.value.open(GDMap, [ele.lnglat.lng,ele.lnglat.lat])
      }
    })
  }
  if(!eventMarkerClusterer1 && type === 'levelId' && levelId === 1){
    eventMarkerClusterer1 = new AMap.MarkerClusterer(
      GDMap,
      markerArr,
      {
        renderClusterMarker: _renderClusterMarker, // 自定义聚合点样式
        renderMarker: _renderMarker, // 自定义非聚合点样式
        gridSize: 0, //聚合计算时网格的像素大小
        maxZoom: 18, //最大的聚合级别
        zoomOnClick:true,
      }
    )
    eventMarkerClusterer1.on('click',(ele)=>{
      if (GDMap.getZoom() === 18) {
        clusterEventArr.value.length = 0
        ele.markers.forEach((item)=>{
          clusterEventArr.value.push(item.getExtData())
        })
        clusterInfoWindow.value = new AMap.InfoWindow({
          offset:new AMap.Pixel(0,-36),
          anchor:'bottom-center',
          content:clusterEventWindowBoxRef.value,
          isCustom:true
        })
        clusterInfoWindow.value.open(GDMap, [ele.lnglat.lng,ele.lnglat.lat])
      }
    })
  }
  if(!eventMarkerClusterer2 && type === 'levelId' && levelId === 2){
    eventMarkerClusterer2 = new AMap.MarkerClusterer(
      GDMap,
      markerArr,
      {
        renderClusterMarker: _renderClusterMarker, // 自定义聚合点样式
        renderMarker: _renderMarker, // 自定义非聚合点样式
        gridSize: 0, //聚合计算时网格的像素大小
        maxZoom: 18, //最大的聚合级别
        zoomOnClick:true,
      }
    )
    eventMarkerClusterer2.on('click',(ele)=>{
      if (GDMap.getZoom() === 18) {
        clusterEventArr.value.length = 0
        ele.markers.forEach((item)=>{
          clusterEventArr.value.push(item.getExtData())
        })
        clusterInfoWindow.value = new AMap.InfoWindow({
          offset:new AMap.Pixel(0,-36),
          anchor:'bottom-center',
          content:clusterEventWindowBoxRef.value,
          isCustom:true
        })
        clusterInfoWindow.value.open(GDMap, [ele.lnglat.lng,ele.lnglat.lat])
      }
    })
  }
  if(!eventMarkerClusterer3 && type === 'levelId' && levelId === 3){
    eventMarkerClusterer3 = new AMap.MarkerClusterer(
      GDMap,
      markerArr,
      {
        renderClusterMarker: _renderClusterMarker, // 自定义聚合点样式
        renderMarker: _renderMarker, // 自定义非聚合点样式
        gridSize: 0, //聚合计算时网格的像素大小
        maxZoom: 18, //最大的聚合级别
        zoomOnClick:true,
      }
    )
    eventMarkerClusterer3.on('click',(ele)=>{
      if (GDMap.getZoom() === 18) {
        clusterEventArr.value.length = 0
        ele.markers.forEach((item)=>{
          clusterEventArr.value.push(item.getExtData())
        })
        clusterInfoWindow.value = new AMap.InfoWindow({
          offset:new AMap.Pixel(0,-36),
          anchor:'bottom-center',
          content:clusterEventWindowBoxRef.value,
          isCustom:true
        })
        clusterInfoWindow.value.open(GDMap, [ele.lnglat.lng,ele.lnglat.lat])
      }
    })
  }
  if(!eventMarkerClusterer4 && type === 'levelId' && levelId === 4){
    eventMarkerClusterer4 = new AMap.MarkerClusterer(
      GDMap,
      markerArr,
      {
        renderClusterMarker: _renderClusterMarker, // 自定义聚合点样式
        renderMarker: _renderMarker, // 自定义非聚合点样式
        gridSize: 0, //聚合计算时网格的像素大小
        maxZoom: 18, //最大的聚合级别
        zoomOnClick:true,
      }
    )
    eventMarkerClusterer4.on('click',(ele)=>{
      if (GDMap.getZoom() === 18) {
        clusterEventArr.value.length = 0
        ele.markers.forEach((item)=>{
          clusterEventArr.value.push(item.getExtData())
        })
        clusterInfoWindow.value = new AMap.InfoWindow({
          offset:new AMap.Pixel(0,-36),
          anchor:'bottom-center',
          content:clusterEventWindowBoxRef.value,
          isCustom:true
        })
        clusterInfoWindow.value.open(GDMap, [ele.lnglat.lng,ele.lnglat.lat])
      }
    })
  }
  if(!eventMarkerClusterer5 && type === 'levelId' && levelId === 5){
    eventMarkerClusterer5 = new AMap.MarkerClusterer(
      GDMap,
      markerArr,
      {
        renderClusterMarker: _renderClusterMarker, // 自定义聚合点样式
        renderMarker: _renderMarker, // 自定义非聚合点样式
        gridSize: 0, //聚合计算时网格的像素大小
        maxZoom: 18, //最大的聚合级别
        zoomOnClick:true,
      }
    )
    eventMarkerClusterer5.on('click',(ele)=>{
      if (GDMap.getZoom() === 18) {
        clusterEventArr.value.length = 0
        ele.markers.forEach((item)=>{
          clusterEventArr.value.push(item.getExtData())
        })
        clusterInfoWindow.value = new AMap.InfoWindow({
          offset:new AMap.Pixel(0,-36),
          anchor:'bottom-center',
          content:clusterEventWindowBoxRef.value,
          isCustom:true
        })
        clusterInfoWindow.value.open(GDMap, [ele.lnglat.lng,ele.lnglat.lat])
      }
    })
  }
}

#container {
  min-height: 968px;
}
/deep/ .markerBox{
  display: flex;
  .markerImage{
    width: 40px;
    height: 40px;
    position: absolute;
    left: -2px;
  }
  .markerContent{
    color: #fff;
    background: #8A6BFA;
    height: 36px;
    line-height: 36px;
    max-width: 265px;
    min-width: 120px;
    border-radius:40px;
    padding-right:10px;
    p{
      margin-left: 45px;
      text-align:left;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
  }
}
/deep/ .renderAnyClusterBox {
  width: 60px;
  height: 60px;
  border-radius: 60px;
}
/deep/ .renderAnyClusterCount {
  width: 42px;
  height: 42px;
  border-radius: 42px;
  line-height: 42px;
  text-align: center;
  color: #fff;
  font-size: 18px;
  margin: auto;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
}
/deep/ .renderClusterBox{
  background: rgba(138, 107, 250, 0.3);
}
/deep/ .renderClusterCount{
  background: rgba(138,107,250,0.8);
  border: 2px solid #6130F0;
}
/deep/ .renderEventClusterBox1{
  background: rgba(252, 105, 59, 0.3);
}
/deep/ .renderEventClusterCount1{
  background: rgba(252, 105, 59, 0.8);
  border: 2px solid rgba(252, 105, 59);
}
/deep/ .renderEventClusterBox2{
  background: rgba(255, 148, 71, 0.3);
}
/deep/ .renderEventClusterCount2{
  background: rgba(255, 148, 71, 0.8);
  border: 2px solid rgba(255, 148, 71);
}
/deep/ .renderEventClusterBox3{
  background: rgba(255, 187, 47, 0.3);
}
/deep/ .renderEventClusterCount3{
  background: rgba(255, 187, 47, 0.8);
  border: 2px solid rgba(255, 187, 47);
}
/deep/ .renderEventClusterBox4{
  background: rgba(27, 127, 255, 0.3);
}
/deep/ .renderEventClusterCount4{
  background: rgba(27, 127, 255, 0.8);
  border: 2px solid rgba(27, 127, 255);
}
/deep/ .renderEventClusterBox5{
  background: rgba(71, 206, 90, 0.3);
}
/deep/ .renderEventClusterCount5{
  background: rgba(71, 206, 90, 0.8);
  border: 2px solid rgba(71, 206, 90);
}
/deep/ .clusterWindowBox{
  display: flex;
  flex-wrap: wrap;
  width: 443px;
  max-height: 295px;
  background: #FFFFFF;
  border-radius: 10px;
  overflow: auto;
  padding: 0 10px 0 20px;
  text-align: left;
  position: relative;
  .oneCluster.clusterWindowItem{
    width:100%;
    border-right: none !important;
  }
  .clusterWindowItem{
    width: 50%;
    font-size: 18px;
    color: #6B7299;
    padding-left: 20px;
    border-top: 1px solid #EEEEEE;
    padding-top:20px;
    padding-bottom:10px;
    padding-right: 20px;
    p{
      margin-bottom:10px;
      margin-top:0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
  }
  .clusterEventWindowItem {
    cursor: pointer;
    font-size: 16px;
  }
  .clusterEventWindowItem-name {
    font-size: 18px;
    font-weight: 700;
  }
  .clusterWindowItem:nth-child(1),.clusterWindowItem:nth-child(2){
    border-top: none;
  }
  .clusterWindowItem:nth-of-type(2n+1){
    padding-left: 0;
    border-right:1px solid #EEEEEE;
  }
}
```



## 轮询接口

```js
// 5分钟刷新一次路况接口及右侧统计接口
let facilitiesAndEventInfoTimer = ref(null)
const circulateEvent = () => {
  facilitiesAndEventInfoTimer.value = setTimeout(() => {
    let parameter = {
      sysOrgCode: sysOrgCode,
    }
    mapObj.sectionIdArr = []
    getHighwaySectionApi(parameter).then((data) => {
        clearTimeout(facilitiesAndEventInfoTimer.value)
        //console.log('getHighwaySectionApiFn-data:', data)
        let result = data.result
        let sectionIdArr = []
        if (data.code == 200) {
          if (result && result.length > 0) {
            result.forEach((e) => {
              sectionIdArr.push(e.sectionId)
            })
            mapObj.sectionIdArr = sectionIdArr.join(',')
            mapObj.eventList = []
            eventPageNo.value = 1
            queryEventInfoApiFn()
            queryConfirmedEventApiFn()
          }
          circulateEvent()
        } else {
          //console.log(data.message)
        }
    })
  }, 30000)
}
```



## 分段渲染多数据

- 通过定时器分段渲染数据，最后循环清除所有定时器

> 注意：做不到通过判断每次渲染条数再去渲染下一段数据，最后等全部数据拿到再渲染到页面上

```js
//根据路段画线路
const _drawPolylineFn = (tmcs,type) => {
    let tmcsLength = 0
        tmcsLength = tmcs.length
    let colorArr = ['#04D099','#FFCC00','#FF0033','#660033'],pathArr = []
    if(tmcs.length>0){
        let polylineColor = ''
        let polyline = ''
        for(let i=0;i<tmcsLength;i++){
            polylineColor = 
                tmcs[i].tmc_status == '畅通'
                ? colorArr[0]
                : tmcs[i].tmc_status == '缓行'
                ? colorArr[1]
                : tmcs[i].tmc_status == '拥堵'
                ? colorArr[2]
                : tmcs[i].tmc_status == '严重拥堵'
                ? colorArr[3]
                : colorArr[0]
            if(tmcs[i].tmc_polyline_arr.length>0){
                polyline = new AMap.Polyline({
                path: tmcs[i].tmc_polyline_arr,
                borderWeight: 2, // 描边的宽度，默认为1
                strokeWeight:5, // 线条宽度
                strokeColor: polylineColor, // 线条颜色
                lineJoin: 'round', // 折线拐点连接处样式
                lineCap:'round',//圆头
                isOutline:true, // 线条是否带描边
                outlineColor:polylineColor, //线条描边颜色
                zIndex: 10
                });
                mapDetailObj.polylineArr.push(polyline);
            }
        }
        GDMap.add(mapDetailObj.polylineArr)
    }
    type++
    let loopFnTimer = setTimeout(function(){
        _loopFn(eventDetailsObj.mapLineData[`${type}`], type)
        if (type === eventDetailsObj.mapLineData.length) {
            loopFnTimerArr.forEach((item) => {
                clearTimeout(item)
            })
            loopFnTimerArr = []
        }
    }, 200)
    loopFnTimerArr.push(loopFnTimer)
}
function _loopFn(lineRoadData,type){
    if(type<eventDetailsObj.mapLineData.length){
        _drawPolylineFn(lineRoadData,type)
    }
}
```



## 动态路由

```javascript
let addRoutes = (menuDatas) => {
    menuDatas.forEach(item => {
        let name = item.name.split('-')[item.name.split('-').length - 1] || ''
        if (item.children && item.children.length != 0) {
            item.children.forEach(v => {
                let names = v.name.split('-')[v.name.split('-').length - 1] || ''
                // console.log("打印看看：", names, v.component)
                router.addRoute('index', {
                    path: v.path,
                    name: names,
                    component: () => import(`@/views/${v.component}`),
                    meta: {
                        title: v.meta.title,
                        keepAlive: v.meta.keepAlive
                    }
                })
            });
        } else if (item.meta.title !== '首页') {
            router.addRoute('index', {
                path: item.path,
                name: name,
                component: () => import(`@/views/${item.component}`),
            })
        }
    });
}
```

